# Лабораторная работа №2. Циклы
## Цели работы
1. Освоить использование операторов цикла в C++
2. Освоить операции ввода-вывода в консоль
## Задание лабораторной работы
1. Получить вариант задания согласно формуле: `N=M mod 24, где N-номер варианта; M-номер по журналу.`
2. Составить блок-схему алгоритма по варианту задания
3. По составленной блок-схеме написать программу на C++
4. Проверить правильность работы программы

## Задания лабораторной работы
1. Вести строку символов и рассчитать количество русских и латинских символов.
2. Заполнить массив `А` из `100` элементов случайными числами, в диапазоне от `1` до `20`. После этого
переписать их в двухмерный массив `А2`, при этом отсортировать из по следующим признакам: в `i` столбец
записываются элементы делящееся на цело на число `i+1`. Полученный массив `А2` выводистя на экран, при этом не заполненные ячейки должны не выводится (рекомендуется записать при инициализации массива в них число `-1` и выводе массива, если в ячейки хранится число `-1`, то она не выводится.
3. Написать ввод строки с возможностью вводить слова разделенные пробелом. Вывести полученную строку.
4. Вести пароль и сравнить его с эталоном. При вводе вместо символов на экране пишется символ `‘*’`, как при вводе пароля при входе в локальную сеть.
5. Вести строку символов и поменять порядок букв в ней на обратный.
6. Заполнить двухмерный массив (`10` на `10` элементов) целых чисел случайными значениями в диапазоне от `10` до `99`. Вывести сходный массив, повернуть его на `90` градусов (строки становятся столбцами) и вывести полученный массив.
7. Заполнить двухмерный массив (`10` на `10` элементов) целых чисел случайными значениями в диапазоне от `10` до `99`. Вывести сходный массив, повернуть его относительно главной диагонали и вывести полученный массив.
8. Определить точность вычислений ЭВМ. Для этого необходимо прибавлять к `1` все уменьшающиеся числа до тех пор, пока текущее значение величины и ее предыдущие значения не будут совпадать. Выполнить это
задание для двух типов: `float` и `double`.
9. Сгенерировать `100` случайных чисел и рассчитать среднее отклонение от среднего значения величин, отдельно для положительных, отдельно для отрицательных отклонений и по абсолютному значению отклонений.
10. Заполнить матрицу `20` на `20` элементами `0` или `1`, в зависимости от нажатия пользователем клавиш `пробел` и `Enter`. До нажатия клавиши `Esc` выполнять последовательный поворот этой фигуры на `90` градусов и выводить ее на экран. Первый раз фигура выводится при формировании. Значение `1` выводится как `‘*’`, значение `0` как `‘ ‘`.
11. Вести две строки, и вывести позицию первого дословного вхождения второй строки в первую.
12. Прочитать строки текста, с возможностью ввода пробела и сохранить их в двухмерном массиве, повернуть полученный массив на `90` градусов и вывести на экран.
13. Ввести строку и зашифровать ее шифром Цезаря. При шифровании шифром Цезаря каждая буква сдвигается по кругу на установленное число, называемое клюем шифра.
14. Ввести строку и зашифровать ее шифром Виженера. При шифровании шифром Цезаря каждая буква сдвигается по кругу на установленное число, разное для каждой позиции. Для удобства обычно придумывает ключевую фразу, каждая буква которой определяет величину сдвига. Ключевая фраза так же повторяется по кругу.
15. Написать генератор решетки для трафаретной системы шифрования. Для трафаретной системы шифрования используется квадрат с прорезями, так что при последовательном его повороте на `90` градусов закрывается все поле письма, но каждая клетка только один раз. Рекомендация: для представления трафарета использовать двух мерный массив со значениями `0` и `1`, означающими наличие прорези или ее отсутствие. Для  организации проверки рекомендуется использовать дополнительный массив.
16. Ввести строку и зашифровать ее шифром простой замены. При этой системе шифрования буквы меняются на другие. Порядок замены является ключом шифра. Для записи ключа рекомендуется ввести массив из `256` символов. Исходный символ подставляется в качестве индекса в массив ключа, содержимое этой ячейки содержит букву соответствующий введенной по шифру простой замены. Для того что бы избежать двойных символов в ключе, предлагается при генерации массива ключа рекомендуется в начале заполнить его в прямом порядке, а затем сделать случайных `200` парных перестановок. В задании необходимо ввести с клавиатуры строку, сгенерировать массив перестановок (ключ), вывести его на экран, зашифровать строку, расшифровать строку и вывести все эти три строки на экран.
17. Сгенерировать `25` неповторяющихся случайных чисел в диапазоне от `10` до `N`. Число `N` вводится с клавиатуры.
18. Построить график модуля функции `A*sin(t)/(t+1)+B`, по `N` точкам. Интервал изменения переменной `Т`, количество точек `N`, значения переменных `А` и `В` вводятся с клавиатуры. График представляется в виде: `[значение времени : переменной]‑‑‑‑‑‑‑‑‑‑‑*, количество символов ‘-‘` соответствует значению функции в этот момент времени.
19. Найти минимальное отличное от `0` число типа `float` и `double`. Для этого предлагается вещественное число делить на `2` до тех пор пока оно отличается от `0`. Как только число совпадет с `0`, необходимо вывести предыдущее значение числа, как минимальное отличное от `0` число.
20. В цикле выводить строку символов. Левый и правый край выводимого текста должен непрерывно меняться.
21. Сгенерировать `100` случайных чисел в интервале от `0` до `100`, рассчитать среднее значение и вычислить количество элементов больше среднего и количество элементов меньше чем среднее значение.
22. Найти решение функции `y(x)=x2-1`, на интервале от `-0.7` до `10` методом деления пополам. При методе деления пополам отрезок `[A,B]` делится пополам, после чего проверяется в какой половине находится решение. Выбранный отрезок опять делится пополам и так до тех пор пока `fabs(y(x))` не станет меньше установленной точности решения. На каждой итерации необходимо выводить в новой троке номер итерации и все параметры метода.
23. Найти решение функции `y(x)=x2-1`, на интервале от `-0.7` до `10` методом секущих. При методе секущих отрезок `[A,B]` делится в пропорции значений функций в точках `А` и `В`, после чего проверяется в какой половине находится решение. Выбранный отрезок опять делится пополам и так до тех пор пока `fabs(y(x))` не станет меньше установленной точности решения. На каждой итерации необходимо выводить в новой строке номер итерации и все параметры метода.